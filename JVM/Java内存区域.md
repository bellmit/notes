[TOC]

# 1. 内存区域
![内存区域](./pic/Java内存区域_内存区域.png)

## 程序计数器
1. 如果线程在运行Java方法，那他记录的是正在执行的虚拟机字节码指令的地址
2. 如果线程在运行native方法，那他记录的值为空

私有内存
JVM内部维护，无OOM(OutOfMemoryError)


## Java虚拟机栈
描述Java方法执行的内存模型

每个方法从执行到结束都对应一个栈帧从入栈到出栈的过程，栈帧存放方法执行过程中的一些数据，包括局部变量表、操作数栈、动态链接和返回地址

局部变量表存放编译期就知道的基本数据类型和对象引用，局部变量表所需的内存空间大小在编译期就确定了，在运行期间不会变


私有内存
如果线程申请的栈深度大于虚拟机允许的深度，则抛出StackOverFlow
如果虚拟机栈扩展时没有足够的内存，则抛出OOM


## 本地方法栈
和虚拟机栈类似，不过是描述本地方法


## Java堆
存放对象实例的内存区域，GC的主要区域

分为新生代和老年代，新生代又分为Eden、from Survivor、to Survivor

为了更好的管理堆内存，或许还会分配出一部分区域作为线程私有的分配缓冲区(TLAB)

共享内存
如果堆空间不够存放实例对象了，将抛出OOM

![Java堆](./pic/Java内存区域_Java堆.png)


## 方法区
存储被加载的类信息、final常量，static静态变量、即时编译器(JIT)编译后的代码等

运行时常量池是方法区的一部分，在加载阶段，存放类加载后Class常量池的内容，包括编译期间生成的字面量或符号引用。在解析阶段，会将运行时常量池的符号引用转化为直接引用，解析过程中也会去查询字符串常量池

运行时常量池具有动态性，不仅可以存放编译期间的Class常量池的内容，在运行期间也可以将常量放入运行时常量池中，例如String.intern()方法

字面量包括：
1. 文本字符串
2. 基本类型的值
3. 被声明为final的常量

符号引用包括：
1. 类和方法的全限定名
2. 字段的名称、描述符
3. 方法的名称、描述符

共享内存
当方法区的内存不够用时，将抛出OOM


# 2. Java的常量池
程序运行时，除非手动向常量池中添加常量(比如调用intern方法)，否则jvm不会自动添加常量到常量池
## 字符串常量池
存放字符串常量
[String](../java基础/String.md)

## Class常量池
每个Class文件有一个Class常量池，存放编译期编译产生的字面量和符号引用

## 运行时常量池
Class常量池被加载到内存后的版本