[TOC]

# 1. Java内存模型(JMM)
Java内存模型定义了线程如何访问变量的规则，这里的变量指的是==类中的实例字段、static字段和构成数组对象的元素，不包括方法中的参数和局部变量(他们本来就是线程私有的)==

内存模型规定：
1. 所有的变量都存储在主内存中(虚拟机内存的一部分)，每个线程又有自己的工作内存
2. 线程的工作内存保存使用到的变量在主内存的拷贝副本(并不会直接拷贝整个对象，只拷贝对象中用到的某个字段)
3. 线程对变量的操作(读取、赋值等)都在工作内存中执行，不能直接读写主内存中的值
3. 不同线程间不能访问其他线程的工作内存，线程间变量值的传递都需通过主内存完成

例如i=10这个赋值，线程在工作内存中先给i赋值10，然后再将新值写入主存中

这里的主内存、工作内存和堆、栈不是一个层次的划分，但是从概念上对应的话，主内存对应堆中的对象实例数据部分，工作内存对应栈中部分区域

![主内存和工作内存](./pic/Java内存模型_主内存和工作内存.jpeg)

# 2. 三个性质
线程间的并发执行要同时保证原子性、可见性和有序性

## 原子性
多个操作必须全部执行或者全部不执行，比如从账户A向账户B转1000元，那么从账户A减去1000元、往账户B加上1000元这两个操作必须是原子性的

JMM保证对基本类型的读取和赋值操作是原子性的
```java
//只有语句1是原子性操作，其他三个语句都不是原子性操作。
x = 10;        //语句1
y = x;         //语句2
x++;           //语句3
x = x + 1;     //语句4

/*
语句1：包含1个操作，将10写入工作内存
语句2：包含2个操作，主存中读取x，再将x写入工作内存。两个操作分别是原子操作，但是合起来就不是原子操作了
语句3|语句4：包含3个操作，主存中读取x的值，将x的值加1，写入新的x的值
*/
```

保证手段：[原子操作的实现原理](./原子操作的实现原理.md)
```
1. synchronized
2. Lock
3. CAS+自旋
```


## 可见性
可见性指多个线程访问同一个变量时，某个线程对变量的修改会立即写到主存中，其他线程能立即看到修改的值

JMM中对于普通变量的修改不能保证可见性，线程对变量的修改什么时候被写入主存是不确定的。当其他线程去主存读时，不一定能读到新的值

线程1执行i=10后，不一定立即将i的值写入主存中。当线程2执行j=i时，回去主存中读取数据i，此时读到的可能还是0不是10，那么j的值也就不是10了
```java
//线程1执行的代码
int i = 0;
i = 10;
 
//线程2执行的代码
j = i;
```


保证手段：
```
1. volatile变量：被volatile修饰的变量，保证线程修改的值会立即写入主存中
2. synchronized：synchronized和Lock保证同一时刻只有一个线程修改变量，在释放锁之前会将修改写入主存中
3. Lock
```


## 有序性
有序性指程序执行的顺序和代码的顺序一致

JMM允许编译器对代码进行指令重排序，但要保证最终执行结果和顺序执行结果一致。并且重排序会考虑指令间的数据依赖性，如果指令B依赖指令A的结果，那么重排序也一定保证指令A在指令B前执行


```java
int a = 10;    //语句1
int r = 2;    //语句2
a = a + 3;    //语句3
r = a*a;     //语句4
```
对于上面的几个语句，可能有以下的重排序结果
```java
int r = 2;    //语句2
int a = 10;    //语句1
a = a + 3;    //语句3
r = a*a;     //语句4
```

但不会有以下重排序结果。因为语句4依赖语句3的结果，所以语句3一定要在语句4之前执行
```java
int r = 2;    //语句2
int a = 10;    //语句1
r = a*a;     //语句4
a = a + 3;    //语句3
```


在单线程中，指令重排序不会影响最终结果。但是在多线程中，指令重排序会影响执行结果
以下语句中，线程1执行语句1和语句2。虽然两个语句之间没有数据依赖性，但如果语句2先被执行，线程2会以为线程1的初始化工作已经执行，就会跳出while循环执行doSomethingwithconfig，但此时loadContext还没有执行好，就会导致出错。所以提供[volatile](./volatile.md)来修饰inited。
```java
//线程1:
context = loadContext();   //语句1
inited = true;             //语句2
 
//线程2:
while(!inited ){
  sleep()
}
doSomethingwithconfig(context);
```

保证手段：
```
1. volatile变量 
2. synchronized
3. Lock
```

### Happens-Before 规则
JVM定义了几个规则，让一个无需控制就能优先于另一个操作完成

1. 单一线程原则
在单线程中，指令重排序后的执行结果和顺序执行结果相同

2. 管程锁定规则
对于同一个锁，一个线程必须执行了unlock，另外一个线程才能执行lock

3. volatile 变量规则
对于一个volatile，如果一个线程要去写这个变量，另一个线程要去读这个变量，那么是写线程先执行

4. 线程启动规则
Thread对象的start()方法先行发生于此线程的每一个动作

5. 线程加入规则
Thread 对象的结束先行发生于 join() 方法返回

6. 线程中断规则
对线程 interrupt() 方法的调用先行发生于被中断线程的代码检测到中断事件的发生，可以通过 interrupted() 方法检测到是否有中断发生

7. 对象终结规则
一个对象的初始化完成(构造函数执行结束)先行发生于它的 finalize() 方法的开始

8. 传递性
如果操作 A 先行发生于操作 B，操作 B 先行发生于操作 C，那么操作 A 先行发生于操作 C
