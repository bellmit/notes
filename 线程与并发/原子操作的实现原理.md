## 参考博文
[【并发编程】CPU cache结构和缓存一致性（MESI协议）](https://blog.csdn.net/reliveIT/article/details/50450136)⚠️
[深入学习缓存一致性问题和缓存一致性协议MESI(一)](https://juejin.im/post/5d67e75a5188256db0644778) ⚠️
[关键字: volatile详解](https://www.pdai.tech/md/java/thread/java-thread-x-key-volatile.html)

[TOC]


# 1. CPU实现原子操作
CPU能保证对主存中同一个缓存行的读取和写入操作是原子的，但对于复杂的操作不能保证，例如i++，所以CPU提供两种机制保证复杂内存操作的原子性：
1. 总线锁定
2. 缓存锁定

Java中的原子性都是在CPU实现原子操作的基础上实现的

## 总线锁定
如果多个CPU对内存中的共享变量进行写操作，他们会将变量从主存中读到工作内存，然后在工作内存中操作并写回主存。

总线锁定指的是当某个处理器要读取某个共享变量，他会在总线上输出LOCK#信号，这个信号会使得主存被处理器完全占用，其他处理器的请求都会阻塞

在总线锁定期间，只有一个线程能访问主存，开销太大。

## 缓存锁定
缓存锁定优化了总线锁定，对于多个线程对t同一变量的访问，缓存锁定只保证该变量内存地址的原子性，而不锁定整个主存。

缓存锁定是利用==缓存一致性协议==实现的：
```
某个处理器将主存中的某个共享变量存在工作内存中，并使用lock指令锁定。当该处理器修改变量后写回主存并改变变量在主存中的地址。
每个处理器都会嗅探在总线上传播的数据来检查自己的缓存行是否过期，当处理器发现自己的缓存行中的变量的主存地址被改了，他就会使该行变成无效。当下次处理该数据的时候，就会重新去主存中读取
```

[volatile](./volatile.md) 就使用缓存锁定实现


两种情况不会使用缓存锁定：
1. 当数据不能被缓存在CPU内部，或者读取的数据跨多个缓存行
2. 有些处理器不支持缓存锁定

# 2. Java实现原子操作
## 锁
[线程安全的实现方法](./线程安全的实现方法.md)

## 自旋+CAS
[CAS](./CAS.md)