# 远程接口调用



将service包的接口打成二方包调用，调用者和服务提供者都需要配置


1. 自己的应用实现service

impl需要注册成hsf服务的提供者，xml配置或者注解配置
服务提供者的配置会发送到
```java
//注解配置（同时包含了@Component注解，首先他得是一个bean，其次才能提供远程服务）
@HSFProvider(serviceInterface = ContentReadService.class, serviceVersion = "${hsf.provider.service.version}")
public class ContentReadServiceImpl implements ContentReadService {
}


//xml配置
//1. bean配置
<bean id="juQianNiuSellerreportService" class="com.taobao.ju.mango.service.mtop.JuQianNiuSellerreportServiceImpl"/>

//2. HSF服务配置
<bean class="com.taobao.hsf.app.spring.util.HSFSpringProviderBean" init-method="init">
	<property name="serviceInterface" value="com.taobao.ju.mango.service.mtop.JuQianNiuSellerreportService"/>
	<property name="target" ref="juQianNiuSellerreportService"/>
	<property name="serviceVersion" value="${hsf.provider.service.version}"/>
	<property name="serializeType" value="java"/>
</bean>
```




2. 别人的应用调用

配置service的consumer，xml配置或者注解配置
```java
//注解配置（同时包含了@autowired注解，首先他得是一个bean，其次才能提供远程服务）
@HSFConsumer(serviceVersion = "${hsf.version.mango}")
private MarketContentApplyService marketContentApplyService;

//xml配置
<bean id="uicReadService" class="com.taobao.hsf.app.spring.util.HSFSpringConsumerBean" init-method="init">
	<property name="interfaceName" value="com.taobao.uic.common.service.userinfo.UicReadService"/>
	<property name="version" value="${hsf.version.uic}"/>
</bean>
```




但是这样的话会有一个问题，当服务端添加一个service的时候，调用端就要在自己的应用中配置对应的HSFSpringConsumerBean，会很麻烦。所以可以直接在服务端通过一个client来包掉这部分配置，服务端将HSFSpringConsumerBean注册好放到一个文件里，然后调用端加载client的时候将文件加载进来，这样就相当于在调用端配置了HSFSpringConsumerBean

以下是服务端代码：
```java
public class CargoClient implements InitializingBean, ApplicationContextAware {
    
    @Override
    public void afterPropertiesSet() throws Exception {
        init();
    }

    public void init() {
        if (started.compareAndSet(false, true)) {
            try {
                if (StringUtils.isBlank(appName)) {
                    throw new CargoException("appName must not be null.");
                }
                //会将配置HSFSpringConsumerBean的文件加载进来
                clientContainer = new CargoClientContext(this);
                Cargo.init(this);
                try {
                    Thread.sleep(maxWaitTimeForCsAddress);
                } catch (InterruptedException e) {
                    logger.error(e.getMessage(), e);
                }
            } catch (Exception e) {
                throw new CargoException("cargo client start exception.", e);
            }
        }
    }
}


public class CargoClientContext extends ClassPathXmlApplicationContext {

    private static final String CONFIG_FILES = "classpath:com/taobao/ju/cargo/bootstrap/config/cargo-hsf.xml";
    public CargoClientContext(CargoClient cargoClient) {
        super(new String[]{CONFIG_FILES}, false);
        this.addBeanFactoryPostProcessor(new PropertyConfigurer(cargoClient, new DiamondConfigLoader()));
        super.refresh();
    }
}
```


下面的文件就是配置了HSFSpringConsumerBean的cargo-hsf.xml
```xml
<?xml version="1.0" encoding="UTF-8"?>
<beans xmlns="http://www.springframework.org/schema/beans"
       xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance"
       xsi:schemaLocation="http://www.springframework.org/schema/beans http://www.springframework.org/schema/beans/spring-beans.xsd"
        default-autowire="byName">

    <bean id="signRecordReadService" class="com.taobao.hsf.app.spring.util.HSFSpringConsumerBean">
        <property name="interfaceName" value="com.taobao.ju.cargo.service.signrecord.SignRecordReadService"/>
        <property name="version" value="${cargo.service.version}"/>
    </bean>

    <bean id="signRecordWriteService" class="com.taobao.hsf.app.spring.util.HSFSpringConsumerBean">
        <property name="interfaceName" value="com.taobao.ju.cargo.service.signrecord.SignRecordWriteService"/>
        <property name="version" value="${cargo.service.version}"/>
    </bean>
</beans>
```
Cargo里面就包含了各个service对应的client
```java
package com.taobao.ju.cargo.bootstrap;
/**
 * @author: liangzhan.qj
 */
public class Cargo {

    public static BranchWriteClient branchUpdate() {
        return applicationContext.getBean("branchWriteClient", BranchWriteClient.class);
    }

    public static MaterialServiceClient material() {
        return applicationContext.getBean("materialServiceClient", MaterialServiceClient.class);
    }
}

```


service对应的client里面就包装了service
```java
package com.taobao.ju.cargo.client.branch;

@Component
public class BranchWriteClient extends ServiceClient {

    @Resource
    private BranchProcessWriteService branchProcessWriteService;

    public Void auditReject(final BranchQueryInfo branchQueryInfo, final BizContext bizContext, final Operator operator) {
        return clientTemplate.execute(new CargoServiceInvoker<Void>() {
            @Override
            public ResultDO<Void> invoke() {
                return branchProcessWriteService.auditReject(branchQueryInfo, bizContext, operator, appInfo);
            }
        });
    }
}

```




在调用端就可以用如下调用:
```java
Cargo.marketContent().query().getContentBySignRecordId(contentQueryInfo, new AppInfo("porsche"));
```


