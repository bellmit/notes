## 参考博文
[基于优先堆的调度队列](https://qiankun214.github.io/2018/03/15/%E5%9F%BA%E4%BA%8E%E4%BC%98%E5%85%88%E5%A0%86%E7%9A%84%E8%B0%83%E5%BA%A6%E9%98%9F%E5%88%97/)

[TOC]

# 1. 要求
考虑优先堆的一种应用场景——按优先级的任务调度队列：每个任务有一个优先级和唯一标号，该调度队列需要具有以下功能：
```
添加任务：将任务添加进调度队列并按优先级置于对应的位置

执行任务：将优先堆中优先级最高的任务取出（并执行）

删除任务：按标号删除队列中的未执行任务

修改任务优先级：修改指定标号任务的优先级
```

# 2. 数据结构
对于任务，考虑使用类封装，对于一个任务类需要以下特征：
```
标号：int型，用于区别任务的标号，每个任务有一个且唯一
优先级：int型，每个任务的优先级，该特征越小则优先级越高
```

同时需要具有以下方法：
```
任务执行方法：调用该任务表示执行了该任务
优先级修改方法：调用该任务修改优先级
```

# 3. 实现
使用2D优先堆实现该优先队列，2D优先堆为完全二叉树，且任意一个节点的值小于其子节点的值。要实现场景中的几种功能，需要以下几种方法：
```
Push：对应添加任务，将任务类插入该优先堆中，调用上移方法。
Pop：对应执行任务，取出2D优先堆根节点的任务，调用下移方法。
Delete：对应删除任务，按标号取出某一节点的任务并调整堆使其满足2D优先堆的条件，调用下移方法
Change：对应修改任务优先级，根据调整的情况调用上移或下移方法
```

可以用多级堆，比如256个优先级，把优先级分成8个大队列。0-64的放到第一个队列，其余的都这么放。每个任务都放到对应的优先级队列中。只有上一个优先级的任务执行完了，才执行下一个。

